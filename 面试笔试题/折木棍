/*
头条笔试题-折木棍

    在你的面前从左到右摆放着n根长短不一的木棍，你每次可以折断一根木棍，并将折断后得到的两根木棍一左一右放在原来的位置（即若原木棍有左邻居，则两根
新木棍必须放在左邻居的右边，若原木棍有右邻居，新木棍必须放在右邻居的左边，所有木棍保持左右排列）。折断后的两根木棍的长度必须为整数，且它们之和等于
折断前的木棍长度。你希望最终从左到右的木棍长度单调不减，那么你需要折断多少次呢？

输入描述：
第一行是一个数n，表示开始时有多少根木棍(1<=n<=3000)第二行有n个数，从第1个到第n个分别表示从左到右的木棍长度。对任意木棍的长度l，有1<=l<=3000。
输出描述
输出一行，一个数，你最少所需的折断木棍的次数x

示例1
输入:
5
3 5 13 9 12

输出
1

说明
你可以将长度为13的木棍折成长度分别为5和8的两根木棍，最终得到的排列是3 5 5 8 9 12
*/
//from: https://leetcode-cn.com/circle/discuss/eXOcnD/view/SecVmv/
// 贪心
int breakNum(vector<int>& nums)
{
    int ans = 0;
    for (int i = nums.size() - 2; i >= 0; i--) // 从后往前遍历，这样更前面的木棍折断不影响后面的结果
    {
        if (nums[i + 1] >= nums[i]) continue;
        // 将当前木棒均匀折断成若干小于等于下一个的小木棒
        int t = (nums[i] - 1) / nums[i + 1]; // 折t次（如nums[i+1]=1）
        ans += t;
        nums[i] /= (t + 1); // 变成t根木棍
    }
    return ans;
}
